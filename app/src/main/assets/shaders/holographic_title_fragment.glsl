precision mediump float;

varying vec2 v_TexCoord;

uniform sampler2D u_Texture;
uniform float u_Time;
uniform float u_GlitchIntensity;
uniform vec3 u_BaseColor;
uniform vec3 u_AccentColor;
uniform float u_Alpha;

// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
// ๐ฎ EFECTO HOLOGRรFICO OPTIMIZADO
// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void main() {
    vec2 uv = v_TexCoord;

    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // 1. GLITCH SIMPLE (sin noise pesado)
    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    float glitchOffset = 0.0;
    if (u_GlitchIntensity > 0.1) {
        float glitchLine = step(0.95, fract(sin(floor(uv.y * 10.0) + u_Time * 5.0) * 43758.5));
        glitchOffset = glitchLine * (sin(u_Time * 50.0) * 0.03) * u_GlitchIntensity;
    }
    vec2 glitchedUV = uv + vec2(glitchOffset, 0.0);

    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // 2. LECTURA DE TEXTURA (solo 1 lectura!)
    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    float textAlpha = texture2D(u_Texture, glitchedUV).a;

    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // 3. SCANLINES SIMPLES
    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    float scanline = sin(uv.y * 100.0 + u_Time * 3.0) * 0.5 + 0.5;
    scanline = mix(0.9, 1.0, scanline);

    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // 4. COLOR HOLOGRรFICO
    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // Mezcla suave entre colores basada en posiciรณn X
    float colorMix = 0.5 + 0.5 * sin(u_Time * 0.8 + uv.x * 3.14159);
    vec3 holoColor = mix(u_BaseColor, u_AccentColor, colorMix);

    // Brillo pulsante
    float pulse = 0.85 + 0.15 * sin(u_Time * 2.5);
    holoColor *= pulse;

    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    // 5. COMPOSICIรN FINAL
    // โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
    vec3 finalColor = holoColor * textAlpha * scanline;

    // Glow sutil (sin lecturas extra de textura)
    float glow = textAlpha * (0.3 + 0.2 * sin(u_Time * 4.0));
    finalColor += vec3(glow * 0.3);

    gl_FragColor = vec4(finalColor, textAlpha * u_Alpha);
}
